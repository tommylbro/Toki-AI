<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toki AI</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Third-party library for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
    <!-- Babel Standalone for JSX compilation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <!-- Firebase CDNs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, serverTimestamp, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // This script is for loading Firebase. The main app script will use these globals.
        // The names here must match the names used in the React destructuring to be available.
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInWithCustomToken = signInWithCustomToken;
        window.signInAnonymously = signInAnonymously;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.collection = collection;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.query = query;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .prose-sm {
            font-size: 0.875rem;
            line-height: 1.5;
        }
        .prose-sm pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            white-space: pre-wrap;
        }
        .prose-sm code {
            font-size: 0.8rem;
        }
        .dot-flashing {
            position: relative;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 0.5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
        }
        .dot-flashing::before {
            left: -10px;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 10px;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 1s;
        }
        @keyframes dot-flashing {
            0% {
                background-color: #e2e8f0;
            }
            50%, 100% {
                background-color: #4a5568;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div id="root" class="w-full h-full max-w-4xl"></div>
    <script type="text/babel">
        // The Firebase functions are loaded by a separate script tag and are globally available.
        const { initializeApp, getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, getFirestore, collection, onSnapshot, addDoc, serverTimestamp, query } = window;

        // Moved all global variable declarations to the top of the script
        const { useState, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;

        // Define global variables with fallbacks
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- API Keys and Models ---
        // Leave the API_KEY as an empty string. The Canvas environment will provide it.
        const API_KEY = "";
        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";

        // Helper function to convert base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Helper function to convert PCM to WAV format
        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // Audio format (1 = PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); // Bits per sample

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write the PCM data
            const pcmView = new Int16Array(pcmData);
            for (let i = 0; i < pcmView.length; i++) {
                view.setInt16(44 + i * 2, pcmView[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        // Helper function for writing strings to a DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Custom Icon Components to replace lucide-react
        const BotIcon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('path', { d: "M12 8V4H8" }),
                React.createElement('rect', { width: "16", height: "12", x: "4", y: "8", rx: "2" }),
                React.createElement('path', { d: "M2 14h2" }),
                React.createElement('path', { d: "M20 14h2" }),
                React.createElement('path', { d: "M15 13l2 2" }),
                React.createElement('path', { d: "M7 13l-2 2" }),
                React.createElement('path', { d: "M12 18h.01" }),
                React.createElement('path', { d: "M7 21h10" }),
                React.createElement('path', { d: "M12 4v4" })
            )
        );

        const UserIcon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('path', { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }),
                React.createElement('circle', { cx: "12", cy: "7", r: "4" })
            )
        );

        const Volume2Icon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('polygon', { points: "11 5 6 9 2 9 2 15 6 15 11 19 11 5" }),
                React.createElement('path', { d: "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" })
            )
        );

        const FileTextIcon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('path', { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }),
                React.createElement('path', { d: "M14 2v4a2 2 0 0 0 2 2h4" }),
                React.createElement('path', { d: "M10 9H8" }),
                React.createElement('path', { d: "M16 13H8" }),
                React.createElement('path', { d: "M16 17H8" })
            )
        );

        const CodeIcon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('path', { d: "m18 16 4-4-4-4" }),
                React.createElement('path', { d: "m6 8-4 4 4 4" }),
                React.createElement('path', { d: "M14.5 4l-5 16" })
            )
        );

        const WandIcon = ({ size = 24, className = "" }) => (
            React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: className },
                React.createElement('path', { d: "M15 14c.2-.8.8-1.5 1.7-2a4.5 4.5 0 0 0 4.3-5.4A1.68 1.68 0 0 0 21 5.3c-1.3-.1-2.6.2-3.8.9a4.5 4.5 0 0 0-4.3 5.4c-.9.9-1.6 2.4-2 3.8-.7 1.4-.2 2.8.3 3.5.7 1.3 2.1 1.6 3.8 1.6h.4c1.7 0 3.1-.3 4-.7l.3-.2" }),
                React.createElement('path', { d: "m12 10-2-2" }),
                React.createElement('path', { d: "m10 8-2-2" })
            )
        );

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = AudioContext ? new AudioContext() : null;

        const App = () => {
            const [input, setInput] = useState('');
            const [messages, setMessages] = useState([]);
            const [isAIGenerating, setIsAIGenerating] = useState(false);
            const [db, setDb] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isCodeMode, setIsCodeMode] = useState(false);
            const messagesEndRef = useRef(null);
            const textareaRef = useRef(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [firestoreError, setFirestoreError] = useState(null); // New state for Firestore errors
            
            // Helper function to safely parse markdown, with a fallback
            const getParsedMarkdown = (content, isCode) => {
                if (window.marked) {
                    const markdown = isCode ? '```javascript\n' + content + '\n```' : content;
                    return window.marked.parse(markdown);
                }
                // Fallback if marked library is not available
                return isCode ? `<pre><code>${content}</code></pre>` : `<p>${content}</p>`;
            };

            useEffect(() => {
                const textarea = textareaRef.current;
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = `${textarea.scrollHeight}px`;
                }
            }, [input]);

            // Combined Firebase initialization, auth state, and Firestore listener logic
            useEffect(() => {
                let unsubscribeAuth = () => {};
                let unsubscribeFirestore = () => {};

                const initialize = async () => {
                    console.log("Initializing Firebase...");
                    if (Object.keys(firebaseConfig).length === 0) {
                        console.error("Firebase config is not available. Running in local mode.");
                        setDb(null);
                        setUserId(crypto.randomUUID());
                        setIsAuthReady(true);
                        return;
                    }

                    try {
                        const appInstance = initializeApp(firebaseConfig);
                        const authInstance = getAuth(appInstance);
                        const dbInstance = getFirestore(appInstance);
                        setDb(dbInstance);

                        // Listen for auth state changes
                        unsubscribeAuth = onAuthStateChanged(authInstance, (user) => {
                            // First, unsubscribe from any previous Firestore listener
                            unsubscribeFirestore();
                            setFirestoreError(null);

                            if (user) {
                                console.log("User signed in:", user.uid);
                                setUserId(user.uid);
                                setIsAuthReady(true);
                                
                                // Now that we have a user, set up the Firestore listener
                                const collectionPath = `/artifacts/${appId}/users/${user.uid}/messages`;
                                console.log("Setting up Firestore listener for path:", collectionPath);
                                
                                const q = query(collection(dbInstance, collectionPath));
                                
                                unsubscribeFirestore = onSnapshot(q, (querySnapshot) => {
                                    const msgs = [];
                                    querySnapshot.forEach((doc) => {
                                        msgs.push({ ...doc.data(), id: doc.id });
                                    });

                                    msgs.sort((a, b) => {
                                        const aMillis = a.timestamp && a.timestamp.toMillis ? a.timestamp.toMillis() : 0;
                                        const bMillis = b.timestamp && b.timestamp.toMillis ? b.timestamp.toMillis() : 0;
                                        return aMillis - bMillis;
                                    });
                                    setMessages(msgs);
                                }, (error) => {
                                    console.error("Error with Firestore onSnapshot:", error);
                                    setFirestoreError(error.message);
                                });

                            } else {
                                console.log("User signed out or failed to sign in.");
                                setUserId(crypto.randomUUID());
                                setIsAuthReady(true);
                                setMessages([]); // Clear messages if the user logs out
                            }
                        }, (error) => {
                            console.error("onAuthStateChanged failed:", error);
                            setUserId(crypto.randomUUID());
                            setIsAuthReady(true);
                            setFirestoreError(error.message);
                        });

                        // Attempt to sign in
                        if (initialAuthToken) {
                            console.log("Attempting sign-in with custom token...");
                            await signInWithCustomToken(authInstance, initialAuthToken);
                        } else {
                            console.log("Attempting anonymous sign-in...");
                            await signInAnonymously(authInstance);
                        }

                    } catch (error) {
                        console.error("Error during Firebase initialization or sign-in:", error);
                        setDb(null);
                        setUserId(crypto.randomUUID());
                        setIsAuthReady(true); // Ensure the app becomes ready even on error
                    }
                };
                
                initialize();
                
                // Cleanup function for the effect
                return () => {
                    unsubscribeAuth();
                    unsubscribeFirestore();
                };
            }, [appId, firebaseConfig, initialAuthToken]); // Dependencies for re-running the effect

            useEffect(() => {
                // Scroll to the bottom of the messages div whenever messages change
                if (messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages]);

            const handleSendMessage = async (prompt, isCode = false) => {
                if (!prompt.trim() || !userId) {
                    console.error("Cannot send message: Missing prompt or user ID.");
                    return;
                }
                
                // Add user message to state immediately for responsiveness
                const newUserMessage = {
                    role: 'user',
                    content: prompt,
                    isCode,
                    timestamp: new Date(),
                };

                setMessages(prevMessages => [...prevMessages, newUserMessage]);
                setInput('');
                setIsAIGenerating(true);
                
                // Persist to Firestore if a db instance is available
                if (db) {
                    try {
                        const collectionPath = `/artifacts/${appId}/users/${userId}/messages`;
                        await addDoc(collection(db, collectionPath), {
                            ...newUserMessage,
                            timestamp: serverTimestamp(),
                        });
                    } catch (error) {
                        console.error("Error writing user message to Firestore:", error);
                        // If Firestore fails, the message will still be in the UI via the state update
                    }
                }

                // Prepare the chat history for the AI API call, converting 'ai' role to 'model'
                const chatHistoryForAPI = messages.map(msg => ({
                    role: msg.role === 'ai' ? 'model' : msg.role,
                    parts: [{ text: msg.content }]
                }));
                chat
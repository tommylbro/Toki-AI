<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toki AI</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Third-party library for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
    <!-- Babel Standalone for JSX compilation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <!-- DOMPurify for sanitizing HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.6/purify.min.js"></script>

    <style>
        /* Import a clean, modern font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        /* Style adjustments for rendered markdown content */
        .prose-sm {
            font-size: 0.875rem;
        }
        .prose {
            color: inherit;
        }
        .prose h1, .prose h2, .prose h3, .prose h4 {
            color: inherit;
        }
        .prose-invert code {
            background-color: #4a5568;
            color: #e2e8f0;
        }
    </style>
</head>
<body class="dark bg-gray-900 text-gray-200 flex flex-col h-screen">
    <div id="root" class="flex-1 overflow-hidden flex flex-col"></div>
    <!-- Loading overlay displayed while the app is initializing -->
    <div id="loading-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900 z-50 transition-opacity duration-300">
        <div class="flex items-center space-x-2 text-indigo-400">
            <div class="w-4 h-4 rounded-full bg-indigo-400 animate-bounce" style="animation-delay: 0s;"></div>
            <div class="w-4 h-4 rounded-full bg-indigo-400 animate-bounce" style="animation-delay: 0.2s;"></div>
            <div class="w-4 h-4 rounded-full bg-indigo-400 animate-bounce" style="animation-delay: 0.4s;"></div>
        </div>
        <span class="mt-4 text-gray-400">Loading application...</span>
    </div>

    <!-- The main application script using Babel for JSX compilation -->
    <script type="text/babel">
        // Import React and hooks from the global React object
        const { useState, useEffect, useRef } = React;

        // Custom Modal Component for displaying messages instead of alert()
        const Modal = ({ message, onClose }) => {
            if (!message) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
                        <p className="text-white mb-4">{message}</p>
                        <button
                            className="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-full hover:bg-indigo-700 transition-colors"
                            onClick={onClose}
                        >
                            Close
                        </button>
                    </div>
                </div>
            );
        };
        
        // Simple mock icons to avoid external dependencies
        const SendIcon = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22 2L11 13" /><path d="M22 2L15 22L11 13L2 9L22 2Z" />
            </svg>
        );
        const UserIcon = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" />
            </svg>
        );
        const BotIcon = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 2L6 22H18L12 2Z" /><path d="M12 2L6 22H18L12 2Z" />
            </svg>
        );
        const LoadingIndicator = () => (
            <div className="flex items-center space-x-2 text-indigo-400">
                <div className="w-2 h-2 rounded-full bg-indigo-400 animate-bounce" style={{ animationDelay: '0s' }}></div>
                <div className="w-2 h-2 rounded-full bg-indigo-400 animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                <div className="w-2 h-2 rounded-full bg-indigo-400 animate-bounce" style={{ animationDelay: '0.4s' }}></div>
            </div>
        );
        const SpeakerIcon = ({ size = 20, onClick }) => (
            <svg onClick={onClick} className="cursor-pointer text-gray-400 hover:text-white transition-colors" xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 5L6 9H2v6h4l5 4V5z" />
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" />
            </svg>
        );
        
        // Helper function to convert base64 to an ArrayBuffer
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        // Helper function to convert raw PCM to a WAV Blob
        const pcmToWav = (pcmData, sampleRate) => {
            const pcm16 = new Int16Array(pcmData);
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);

            const writeString = (offset, str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            };

            // RIFF chunk
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + pcm16.length * 2, true);
            writeString(8, 'WAVE');

            // fmt chunk
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, 1, true); // Mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); // Byte rate
            view.setUint16(32, 2, true); // Block align
            view.setUint16(34, 16, true); // Bits per sample

            // data chunk
            writeString(36, 'data');
            view.setUint32(40, pcm16.length * 2, true);
            
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(44 + i * 2, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        };

        // A simple wrapper component for markdown rendering with code highlighting
        const MarkdownRenderer = ({ content }) => {
            if (!window.marked || !content) {
                return null;
            }
            try {
                const sanitizedHtml = DOMPurify.sanitize(window.marked.parse(content));
                return <div className="prose prose-invert prose-sm text-gray-200 max-w-none break-words" dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />;
            } catch (error) {
                console.error("Markdown rendering failed:", error);
                return <div className="text-red-400">Error rendering markdown.</div>;
            }
        };

        const ChatMessage = ({ message, onReadAloud }) => {
            const { content, role } = message;
            const isUser = role === 'user';
            const bgColor = isUser ? 'bg-gray-800' : 'bg-gray-700';
            const icon = isUser ? <UserIcon size={20} /> : <BotIcon size={20} />;

            return (
                <div className={`flex items-start gap-4 p-4 rounded-xl shadow-md ${bgColor} `}>
                    <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-indigo-500 flex items-center justify-center text-white">
                            {icon}
                        </div>
                    </div>
                    <div className="flex-1">
                        <div className="flex justify-between items-center">
                            <p className="font-semibold capitalize">{isUser ? 'You' : 'Toki'}</p>
                            {!isUser && (
                                <SpeakerIcon onClick={() => onReadAloud(content)} />
                            )}
                        </div>
                        <div className="mt-1 text-sm">
                            <MarkdownRenderer content={content} />
                        </div>
                    </div>
                </div>
            );
        };

        const ImageMessage = ({ message }) => {
            const { content: imageUrl } = message;
            return (
                <div className={`flex items-start gap-4 p-4 rounded-xl shadow-md bg-gray-700`}>
                    <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-indigo-500 flex items-center justify-center text-white">
                            <BotIcon size={20} />
                        </div>
                    </div>
                    <div className="flex-1">
                        <p className="font-semibold">Toki</p>
                        <div className="mt-1 text-sm">
                            <img src={imageUrl} alt="Generated content" className="rounded-lg max-w-full h-auto" />
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [input, setInput] = useState('');
            const [isAIGenerating, setIsAIGenerating] = useState(false);
            const [mode, setMode] = useState('chat');
            const [rewritingTone, setRewritingTone] = useState('formal');
            const [errorMessage, setErrorMessage] = useState(null);
            const chatContainerRef = useRef(null);
            // FIX: Removed the hardcoded API key to use the environment's key.
            const apiKey = "";

            const initialWelcomeMessage = { role: 'model', content: 'Hello! I am Toki, your AI assistant. How can I help you today?' };
            const [chatHistory, setChatHistory] = useState([initialWelcomeMessage]);
            const [writingHistory, setWritingHistory] = useState([]);
            const [codeHistory, setCodeHistory] = useState([]);
            const [imageHistory, setImageHistory] = useState([]);

            // This useEffect hook runs once on component mount to hide the loading overlay.
            useEffect(() => {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.style.display = 'none', 300);
                }
            }, []);

            // This useEffect hook auto-scrolls the chat window when new messages are added.
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [chatHistory, writingHistory, codeHistory, imageHistory, isAIGenerating]);

            // Fetcher utility for API calls with exponential backoff
            const fetchWithRetry = async (url, options, retries = 3) => {
                let delay = 1000;
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.ok) {
                            return await response.json();
                        } else if (response.status === 429) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorText = await response.text();
                            throw new Error(`API call failed with status: ${response.status}. Response: ${errorText}`);
                        }
                    } catch (error) {
                        if (i === retries - 1) throw error;
                    }
                }
            };
            
            // Text Generation Function
            const generateText = async (history, prompt) => {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const contents = history.map(message => ({
                    role: message.role === 'user' ? 'user' : 'model',
                    parts: [{ text: message.content }]
                }));
                
                // Add the new prompt to the contents array for the API call
                contents.push({ role: 'user', parts: [{ text: prompt }] });

                const payload = { contents };
                
                try {
                    const result = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (result && result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error("Invalid API response format");
                    }
                } catch (error) {
                    console.error("Failed to generate content:", error);
                    throw error;
                }
            };
            
            // Image Generation Function
            const generateImage = async (prompt) => {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 1} };

                try {
                    const result = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (result && result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    } else {
                        throw new Error("Invalid image API response format");
                    }
                } catch (error) {
                    console.error("Failed to generate image:", error);
                    throw error;
                }
            };

            // TTS Generation Function
            const generateTTS = async (text) => {
                const payload = {
                    contents: [{
                        parts: [{ text: text }]
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Kore" }
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                try {
                    const response = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const part = (response && response.candidates && response.candidates.length > 0 && response.candidates[0].content && response.candidates[0].content.parts && response.candidates[0].content.parts.length > 0) ? response.candidates[0].content.parts[0] : null;

                    if (part && part.inlineData && part.inlineData.data && part.inlineData.mimeType && part.inlineData.mimeType.startsWith("audio/")) {
                        const mimeType = part.inlineData.mimeType;
                        const audioData = part.inlineData.data;
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const wavBlob = pcmToWav(pcmData, sampleRate);
                        return URL.createObjectURL(wavBlob);
                    } else {
                        console.error("Invalid TTS API response format or missing data.");
                        throw new Error("Invalid TTS API response format");
                    }
                } catch (error) {
                    console.error("Failed to read aloud:", error);
                    throw error;
                }
            };

            // FIX: Refactored message handling for all modes to ensure correct history is passed to the API.
            const handleSendMessage = async () => {
                const prompt = input.trim();
                if (!prompt || isAIGenerating) return;

                setIsAIGenerating(true);
                const userMessage = { role: 'user', content: prompt };
                setInput('');

                try {
                    if (mode === 'chat') {
                        // FIX: Create new history with user message before calling the API
                        const newChatHistory = [...chatHistory, userMessage];
                        setChatHistory(newChatHistory);
                        const responseContent = await generateText(newChatHistory, prompt);
                        setChatHistory(prev => [...prev, { role: 'model', content: responseContent }]);
                    } else if (mode === 'image') {
                        // FIX: Added the user message to the history and cleared the input
                        setImageHistory(prev => [...prev, userMessage]);
                        const imageUrl = await generateImage(prompt);
                        setImageHistory(prev => [...prev, { role: 'model-image', content: imageUrl }]);
                    }
                } catch (error) {
                    console.error("Failed to process request:", error);
                    setErrorMessage('An error occurred while processing your request. Please ensure you have a valid API key.');
                    // Add an error message to the history if the API fails
                    if (mode === 'chat') {
                        setChatHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                    } else if (mode === 'image') {
                        setImageHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                    }
                } finally {
                    setIsAIGenerating(false);
                }
            };
            
            // Feature 1: Summarize Text ✨
            const handleSummarize = async () => {
                const prompt = input.trim();
                if (!prompt || isAIGenerating) return;
                
                setIsAIGenerating(true);
                const userMessage = { role: 'user', content: prompt };
                setInput('');

                try {
                    // FIX: Create new history with user message before calling the API
                    const newWritingHistory = [...writingHistory, userMessage];
                    setWritingHistory(newWritingHistory);
                    const responseContent = await generateText(newWritingHistory, `Summarize the following text:\n\n${userMessage.content}`);
                    setWritingHistory(prev => [...prev, { role: 'model', content: `**Summary:**\n\n${responseContent}` }]);
                } catch (error) {
                    console.error("Failed to summarize text:", error);
                    setErrorMessage('An error occurred while summarizing the text. Please ensure you have a valid API key.');
                    setWritingHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                } finally {
                    setIsAIGenerating(false);
                }
            };

            // Feature 2: Continue Writing ✨
            const handleContinueWriting = async () => {
                const prompt = input.trim();
                if (!prompt || isAIGenerating) return;

                setIsAIGenerating(true);
                const userMessage = { role: 'user', content: prompt };
                setInput('');

                try {
                    // FIX: Create new history with user message before calling the API
                    const newWritingHistory = [...writingHistory, userMessage];
                    setWritingHistory(newWritingHistory);
                    const responseContent = await generateText(newWritingHistory, `Continue the following text:\n\n${userMessage.content}`);
                    setWritingHistory(prev => [...prev, { role: 'model', content: `**Continued Text:**\n\n${responseContent}` }]);
                } catch (error) {
                    console.error("Failed to continue writing:", error);
                    setErrorMessage('An error occurred while continuing the text. Please ensure you have a valid API key.');
                    setWritingHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                } finally {
                    setIsAIGenerating(false);
                }
            };
            
            // New Feature 3: Rewrite Text ✨
            const handleRewrite = async () => {
                const prompt = input.trim();
                if (!prompt || isAIGenerating) return;

                setIsAIGenerating(true);
                const userMessage = { role: 'user', content: prompt };
                setInput('');

                try {
                    // FIX: Create new history with user message before calling the API
                    const newWritingHistory = [...writingHistory, userMessage];
                    setWritingHistory(newWritingHistory);
                    const responseContent = await generateText(newWritingHistory, `Rewrite the following text in a ${rewritingTone} tone:\n\n${userMessage.content}`);
                    setWritingHistory(prev => [...prev, { role: 'model', content: `**Rewritten (${rewritingTone}):**\n\n${responseContent}` }]);
                } catch (error) {
                    console.error("Failed to rewrite text:", error);
                    setErrorMessage('An error occurred while rewriting the text. Please ensure you have a valid API key.');
                    setWritingHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                } finally {
                    setIsAIGenerating(false);
                }
            };
            
            // New Feature 4: Explain Code ✨
            const handleExplainCode = async () => {
                const prompt = input.trim();
                if (!prompt || isAIGenerating) return;

                setIsAIGenerating(true);
                const userMessage = { role: 'user', content: prompt };
                setInput('');

                try {
                    // FIX: Create new history with user message before calling the API
                    const newCodeHistory = [...codeHistory, userMessage];
                    setCodeHistory(newCodeHistory);
                    const responseContent = await generateText(newCodeHistory, `Explain the following code snippet. Break down what it does, how it works, and its purpose:\n\n${userMessage.content}`);
                    setCodeHistory(prev => [...prev, { role: 'model', content: `**Code Explanation:**\n\n${responseContent}` }]);
                } catch (error) {
                    console.error("Failed to explain code:", error);
                    setErrorMessage('An error occurred while explaining the code. Please ensure you have a valid API key.');
                    setCodeHistory(prev => [...prev, { role: 'model', content: 'An error occurred. Please ensure you have a valid API key.' }]);
                } finally {
                    setIsAIGenerating(false);
                }
            };
            
            // Existing Feature: Read Aloud a message with Gemini TTS API ✨
            const handleReadAloud = async (text) => {
                if (isAIGenerating) return;

                setIsAIGenerating(true);
                setErrorMessage('Generating audio...');

                try {
                    const audioUrl = await generateTTS(text);
                    const audio = new Audio(audioUrl);
                    audio.play();
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        setErrorMessage(null);
                    };
                    setErrorMessage('Playing audio...');
                } catch (error) {
                    console.error("Failed to read aloud:", error);
                    setErrorMessage('An error occurred while generating audio. Please ensure you have a valid API key.');
                } finally {
                    setIsAIGenerating(false);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (mode === 'chat' || mode === 'image') {
                        handleSendMessage();
                    } else if (mode === 'writing' || mode === 'code') {
                        // The user can't send messages in writing or code modes with enter, they have to click the button
                        return;
                    }
                }
            };

            const getPlaceholderText = (currentMode) => {
                switch (currentMode) {
                    case 'writing':
                        return 'Enter your text to summarize, continue, or rewrite...';
                    case 'code':
                        return 'Paste a code snippet here to get an explanation...';
                    case 'image':
                        return 'Describe the image you want to generate...';
                    case 'chat':
                        return 'Start a conversation with Toki...';
                    default:
                        return 'Enter your prompt...';
                }
            };

            // This function determines which history to render
            const getActiveHistory = () => {
                switch (mode) {
                    case 'writing':
                        return writingHistory;
                    case 'code':
                        return codeHistory;
                    case 'image':
                        return imageHistory;
                    case 'chat':
                    default:
                        return chatHistory;
                }
            };

            return (
                <div className="flex flex-col h-full bg-gray-900 text-gray-200">
                    <Modal message={errorMessage} onClose={() => setErrorMessage(null)} />
                    <header className="p-4 bg-gray-800 shadow-md">
                        <h1 className="text-2xl font-bold text-center text-indigo-400">Toki AI</h1>
                    </header>
                    <main ref={chatContainerRef} className="flex-1 p-4 overflow-y-auto space-y-4">
                        {getActiveHistory().map((message, index) => (
                            message.role === 'model-image' ? (
                                <ImageMessage key={index} message={message} />
                            ) : (
                                <ChatMessage key={index} message={message} onReadAloud={handleReadAloud} />
                            )
                        ))}
                        {isAIGenerating && (
                            <div className="flex items-start gap-4 p-4 rounded-xl shadow-md bg-gray-700">
                                <div className="flex-shrink-0">
                                    <div className="w-8 h-8 rounded-full bg-indigo-500 flex items-center justify-center text-white">
                                        <BotIcon size={20} />
                                    </div>
                                </div>
                                <div className="flex-1 mt-2">
                                    <LoadingIndicator />
                                </div>
                            </div>
                        )}
                    </main>
                    <footer className="p-4 bg-gray-800 shadow-inner">
                        <div className="flex flex-col sm:flex-row items-stretch gap-2 mb-4">
                             <div className="flex-1">
                                 <label className="block text-sm font-medium mb-1 text-gray-300">
                                     Select Mode:
                                 </label>
                                 <select
                                     value={mode}
                                     onChange={(e) => setMode(e.target.value)}
                                     className="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                 >
                                     <option value="writing">Writing</option>
                                     <option value="code">Code</option>
                                     <option value="image">Image Generation</option>
                                     <option value="chat">Gemini Chat</option>
                                 </select>
                             </div>
                        </div>
                        <div className="flex items-center gap-2">
                            {mode === 'writing' && (
                                <div className="flex gap-2 flex-wrap">
                                    <button
                                        className={`p-3 rounded-full transition-colors font-bold text-sm ${isAIGenerating || !input ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                        onClick={handleSummarize}
                                        disabled={isAIGenerating || !input}
                                        title="Summarize Text"
                                    >
                                        Summarize ✨
                                    </button>
                                    <button
                                        className={`p-3 rounded-full transition-colors font-bold text-sm ${isAIGenerating || !input ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                        onClick={handleContinueWriting}
                                        disabled={isAIGenerating || !input}
                                        title="Continue Writing"
                                    >
                                        Continue Writing ✨
                                    </button>
                                    <select
                                        value={rewritingTone}
                                        onChange={(e) => setRewritingTone(e.target.value)}
                                        className="p-3 rounded-full bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm font-bold"
                                        disabled={isAIGenerating || !input}
                                    >
                                        <option value="formal">Formal</option>
                                        <option value="casual">Casual</option>
                                        <option value="professional">Professional</option>
                                        <option value="creative">Creative</option>
                                    </select>
                                    <button
                                        className={`p-3 rounded-full transition-colors font-bold text-sm ${isAIGenerating || !input ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                        onClick={handleRewrite}
                                        disabled={isAIGenerating || !input}
                                        title="Rewrite Text"
                                    >
                                        Rewrite ✨
                                    </button>
                                </div>
                            )}
                            {mode === 'code' && (
                                <button
                                    className={`p-3 rounded-full transition-colors font-bold text-sm ${isAIGenerating || !input ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                    onClick={handleExplainCode}
                                    disabled={isAIGenerating || !input}
                                    title="Explain Code"
                                >
                                    Explain Code ✨
                                </button>
                            )}
                            {(mode === 'chat' || mode === 'image') && (
                                <div className="flex flex-grow items-center">
                                    <textarea
                                        className="flex-1 p-3 rounded-full bg-gray-700 border border-gray-600 text-white resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500 overflow-hidden"
                                        placeholder={getPlaceholderText(mode)}
                                        rows="1"
                                        value={input}
                                        onChange={(e) => setInput(e.target.value)}
                                        onKeyDown={handleKeyDown}
                                        disabled={isAIGenerating}
                                    ></textarea>
                                    <button
                                        className={`p-3 rounded-full ml-2 transition-colors ${isAIGenerating || !input ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                        onClick={handleSendMessage}
                                        disabled={isAIGenerating || !input}
                                        title="Send Message"
                                    >
                                        <SendIcon size={24} />
                                    </button>
                                </div>
                            )}
                        </div>
                    </footer>
                </div>
            );
        };

        // Render the main App component into the root element
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>

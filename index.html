<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Madison AI</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Third-party library for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
    <!-- Babel Standalone for JSX compilation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .prose-sm {
            font-size: 0.875rem;
            line-height: 1.5;
        }
        .prose-sm pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            white-space: pre-wrap;
        }
        .prose-sm code {
            font-size: 0.8rem;
        }
        .dot-flashing {
            position: relative;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 0.5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
        }
        .dot-flashing::before {
            left: -10px;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 10px;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #e2e8f0;
            animation: dot-flashing 1s infinite linear alternate;
            animation-delay: 1s;
        }
        @keyframes dot-flashing {
            0% {
                background-color: #e2e8f0;
            }
            50%, 100% {
                background-color: #4a5568;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div id="root" class="w-full h-full max-w-4xl"></div>

    <!-- Firebase Initialization and Global Variables -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, serverTimestamp, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase services globally for the JSX script
        window.firebase = {
            initializeApp,
            getAuth,
            signInWithCustomToken,
            signInAnonymously,
            onAuthStateChanged,
            getFirestore,
            collection,
            onSnapshot,
            addDoc,
            serverTimestamp,
            query
        };

        // Define global variables with fallbacks
        window.firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        window.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- API Keys and Models ---
        // Use the API key from the environment
        window.API_KEY = typeof __api_key !== 'undefined' ? __api_key : "AIzaSyBvD0xGYQpFTND8Eqnh-KWhDA9YKQHZ6jg";
        window.TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        window.IMAGE_ANALYSIS_MODEL = "gemini-2.5-flash-preview-05-20";
        window.IMAGE_GENERATION_MODEL = "imagen-3.0-generate-002";
        window.TTS_MODEL = "gemini-2.5-flash-preview-tts";

        // Helper functions
        window.base64ToArrayBuffer = function(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        window.pcmToWav = function(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // Audio format (1 = PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); // Bits per sample

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write the PCM data
            const pcmView = new Int16Array(pcmData);
            for (let i = 0; i < pcmView.length; i++) {
                view.setInt16(44 + i * 2, pcmView[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        };

        window.writeString = function(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
    </script>

    <!-- Main React Application with JSX -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;

        // Custom Icon Components to replace lucide-react
        const BotIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 8V4H8" />
                <rect width="16" height="12" x="4" y="8" rx="2" />
                <path d="M2 14h2" />
                <path d="M20 14h2" />
                <path d="M15 13l2 2" />
                <path d="M7 13l-2 2" />
                <path d="M12 18h.01" />
                <path d="M7 21h10" />
                <path d="M12 4v4" />
            </svg>
        );

        const UserIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
                <circle cx="12" cy="7" r="4" />
            </svg>
        );

        const Volume2Icon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" />
            </svg>
        );

        const SendIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M22 2 11 13" />
                <path d="m22 2-7 20-4-9-9-4 20-7Z" />
            </svg>
        );

        const ImageIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
                <circle cx="9" cy="9" r="2" />
                <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" />
            </svg>
        );

        const WandIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M15 4l-1.5 1.5m3 3L16.5 9m-1.5 1.5L15 12" />
                <path d="M10 2l-1.5 1.5m3 3L11.5 7m-1.5 1.5L10 10" />
                <path d="M12 22l-1.5-1.5m-3-3L8.5 18m1.5-1.5L10 15" />
                <path d="M17 18l-1.5-1.5m3-3L18.5 12m-1.5-1.5L17 9" />
                <path d="M12 2l-1.5 1.5m3 3L11.5 7m-1.5 1.5L10 10" />
            </svg>
        );

        const CodeIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m18 16 4-4-4-4" />
                <path d="m6 8-4 4 4 4" />
                <path d="m14.5 4-5 16" />
            </svg>
        );

        const SquareMenuIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect width="18" height="18" x="3" y="3" rx="2" />
                <path d="M7 8h10" />
                <path d="M7 12h10" />
                <path d="M7 16h10" />
            </svg>
        );

        const MessageSquareTextIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
                <line x1="13" x2="13" y1="12" y2="12" />
                <line x1="9" x2="9" y1="12" y2="12" />
            </svg>
        );

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = AudioContext ? new AudioContext() : null;
        
        const App = () => {
            const [input, setInput] = useState('');
            const [messages, setMessages] = useState([]);
            const [isAIGenerating, setIsAIGenerating] = useState(false);
            const [db, setDb] = useState(null);
            const [userId, setUserId] = useState(null);
            const messagesEndRef = useRef(null);
            const textareaRef = useRef(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [firestoreError, setFirestoreError] = useState(null);
            const [apiKeyError, setApiKeyError] = useState('');
            const [selectedImage, setSelectedImage] = useState(null);
            const fileInputRef = useRef(null);
            const [mode, setMode] = useState('chat'); // 'chat', 'writing', 'code'
            const [canvasContent, setCanvasContent] = useState(null);
            const [canvasTitle, setCanvasTitle] = useState('');
            const [canvasId, setCanvasId] = useState('');
            
            // Helper function to safely parse markdown, with a fallback
            const getParsedMarkdown = (content) => {
                if (window.marked) {
                    return window.marked.parse(content);
                }
                // Fallback if marked library is not available
                return `<p>${content}</p>`;
            };

            useEffect(() => {
                const textarea = textareaRef.current;
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = `${textarea.scrollHeight}px`;
                }
            }, [input]);

            // Firebase initialization and auth logic
            useEffect(() => {
                let unsubscribe = () => {};
                
                // Only initialize if firebaseConfig is available
                if (window.firebaseConfig && Object.keys(window.firebaseConfig).length > 0) {
                    try {
                        const appInstance = window.firebase.initializeApp(window.firebaseConfig);
                        const authInstance = window.firebase.getAuth(appInstance);
                        const dbInstance = window.firebase.getFirestore(appInstance);
                        setDb(dbInstance);

                        // Set up the authentication listener
                        unsubscribe = window.firebase.onAuthStateChanged(authInstance, async (user) => {
                            if (user) {
                                setUserId(user.uid);
                            } else {
                                // Sign in anonymously if no user is found
                                try {
                                    if (window.initialAuthToken) {
                                        await window.firebase.signInWithCustomToken(authInstance, window.initialAuthToken);
                                    } else {
                                        await window.firebase.signInAnonymously(authInstance);
                                    }
                                } catch (error) {
                                    console.error("Firebase Auth Error:", error);
                                    setFirestoreError(error.message);
                                }
                            }
                            setIsAuthReady(true);
                        });
                    } catch (error) {
                        console.error("Firebase Initialization Error:", error);
                        setFirestoreError(error.message);
                        setIsAuthReady(true);
                    }
                } else {
                    console.warn("Firebase config not found. Running in offline mode.");
                    setUserId(crypto.randomUUID());
                    setIsAuthReady(true);
                }
                
                // Cleanup function
                return () => {
                    if (unsubscribe) {
                        unsubscribe();
                    }
                };
            }, []);

            // Check for API key on load
            useEffect(() => {
                if (!window.API_KEY || window.API_KEY.length === 0) {
                    setApiKeyError("The API key is missing. Please ensure your environment is configured with a valid API key.");
                } else {
                    setApiKeyError('');
                }
            }, []);

            // Firestore data listener
            useEffect(() => {
                if (db && userId && isAuthReady && mode === 'chat') {
                    const collectionPath = `/artifacts/${window.appId}/users/${userId}/messages`;
                    const q = window.firebase.query(window.firebase.collection(db, collectionPath));
                    
                    const unsubscribe = window.firebase.onSnapshot(q, (querySnapshot) => {
                        const msgs = [];
                        querySnapshot.forEach((doc) => {
                            msgs.push({ ...doc.data(), id: doc.id });
                        });
                        msgs.sort((a, b) => {
                            const aMillis = a.timestamp && a.timestamp.toMillis ? a.timestamp.toMillis() : 0;
                            const bMillis = b.timestamp && b.timestamp.toMillis ? b.timestamp.toMillis() : 0;
                            return aMillis - bMillis;
                        });
                        setMessages(msgs);
                    }, (error) => {
                        console.error("Error with Firestore onSnapshot:", error);
                        setFirestoreError(error.message);
                    });

                    return () => unsubscribe();
                }
            }, [db, userId, isAuthReady, mode]);

            useEffect(() => {
                if (messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages, canvasContent]);
            
            const handleImageChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setSelectedImage(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            const handleRemoveImage = () => {
                setSelectedImage(null);
                if (fileInputRef.current) {
                    fileInputRef.current.value = null;
                }
            };

            const fetchWithRetry = async (url, options, retries = 5) => {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.status === 429 && i < retries - 1) {
                            console.warn(`API call failed with status 429. Retrying in ${Math.pow(2, i)} seconds...`);
                            const delay = Math.pow(2, i) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        return response;
                    } catch (error) {
                        if (i < retries - 1) {
                            console.warn(`API call failed. Retrying in ${Math.pow(2, i)} seconds...`);
                            const delay = Math.pow(2, i) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw error;
                    }
                }
                throw new Error("Failed to fetch after multiple retries.");
            };
            
            const handleSendMessage = async (prompt) => {
                if (!prompt.trim() && !selectedImage) {
                    console.error("Cannot send message: Missing prompt or image.");
                    return;
                }
                if (!userId) {
                    console.error("Cannot send message: Missing user ID.");
                    return;
                }
                if (apiKeyError) {
                    setMessages(prevMessages => [...prevMessages, {
                        role: 'ai',
                        content: apiKeyError,
                    }]);
                    return;
                }
                
                let newUserMessage = {
                    role: 'user',
                    content: prompt,
                    timestamp: new Date(),
                    image: selectedImage,
                };
                
                setMessages(prevMessages => [...prevMessages, newUserMessage]);
                setInput('');
                setSelectedImage(null);
                if (fileInputRef.current) {
                    fileInputRef.current.value = null;
                }
                setIsAIGenerating(true);
                
                if (db) {
                    try {
                        const collectionPath = `/artifacts/${window.appId}/users/${userId}/messages`;
                        await window.firebase.addDoc(window.firebase.collection(db, collectionPath), {
                            ...newUserMessage,
                            timestamp: window.firebase.serverTimestamp(),
                        });
                    } catch (error) {
                        console.error("Error writing user message to Firestore:", error);
                    }
                }

                let aiText = "I'm sorry, I couldn't get a response from the AI at the moment. Please try again later.";
                
                if (selectedImage) {
                    // Handle image analysis request
                    const base64ImageData = selectedImage.split(',')[1];
                    const payload = {
                        contents: [
                            {
                                role: "user",
                                parts: [
                                    { text: prompt },
                                    {
                                        inlineData: {
                                            mimeType: "image/png",
                                            data: base64ImageData
                                        }
                                    }
                                ]
                            }
                        ],
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.IMAGE_ANALYSIS_MODEL}:generateContent?key=${window.API_KEY}`;
                    try {
                        const response = await fetchWithRetry(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json();
                        aiText = (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text) || aiText;
                    } catch (error) {
                         console.error("Error with image analysis API:", error);
                         aiText = `Error analyzing image: ${error.message}`;
                    } finally {
                        sendAIMessage(aiText);
                    }
                } else if (prompt.trim().toLowerCase().startsWith("generate image")) {
                    // Handle image generation request
                    const imagePrompt = prompt.substring("generate image".length).trim();
                    const payload = {
                        instances: [{ prompt: imagePrompt }],
                        parameters: { "sampleCount": 1 }
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.IMAGE_GENERATION_MODEL}:predict?key=${window.API_KEY}`;
                    
                    try {
                        const response = await fetchWithRetry(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json();
                        const base64Data = (result.predictions && result.predictions[0] && result.predictions[0].bytesBase64Encoded);
                        if (base64Data) {
                            const imageUrl = `data:image/png;base64,${base64Data}`;
                            aiText = `[Image generated from prompt: "${imagePrompt}"]\n\n![Generated Image](${imageUrl})`;
                        } else {
                            throw new Error("Invalid or empty image data in response.");
                        }
                    } catch (error) {
                        console.error("Error with image generation API:", error);
                        aiText = `Error generating image: ${error.message}`;
                    } finally {
                        sendAIMessage(aiText);
                    }
                } else {
                    // Handle text-only chat request
                    const chatHistoryForAPI = messages.map(msg => ({
                        role: msg.role === 'ai' ? 'model' : msg.role,
                        parts: [{ text: msg.content }]
                    }));
                    chatHistoryForAPI.push({ role: 'user', parts: [{ text: prompt }] });
                    
                    const payload = {
                        contents: chatHistoryForAPI,
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.TEXT_MODEL}:generateContent?key=${window.API_KEY}`;
                    try {
                        const response = await fetchWithRetry(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!response.ok) {
                            let errorData = await response.json();
                            throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error.message}`);
                        }
                        const result = await response.json();
                        aiText = (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text) || aiText;
                    } catch (error) {
                        console.error("Error fetching AI response:", error);
                        if (error.message.includes('401') || error.message.includes('403')) {
                            aiText = "I'm sorry, there was an authentication error with the AI service. The API key is likely invalid or missing. Please check and update the `API_KEY` constant in the code.";
                        } else {
                            aiText = error.message;
                        }
                    } finally {
                        sendAIMessage(aiText);
                    }
                }
            };

            const handleGenerateCanvas = async (prompt, canvasMode) => {
                if (!prompt.trim()) {
                    console.error("Cannot generate canvas: Missing prompt.");
                    return;
                }
                if (!userId) {
                    console.error("Cannot generate canvas: Missing user ID.");
                    return;
                }
                if (apiKeyError) {
                    setCanvasContent(apiKeyError);
                    setCanvasTitle("API Error");
                    return;
                }
                
                setIsAIGenerating(true);
                setCanvasContent(null);
                setCanvasTitle('');

                let aiText = "I'm sorry, I couldn't generate the canvas at the moment. Please try again later.";
                let title = `Generated ${canvasMode} Document`;
                let immersiveId = `${canvasMode}-document-${Date.now()}`;
                
                let systemPrompt = "";
                if (canvasMode === 'code') {
                    systemPrompt = "You are a coding assistant. Provide a complete, well-commented code block in the specified language to explain the user's request. Only provide the code and relevant comments, no extra conversational text. Ensure the code is self-contained and runnable.";
                    title = "Code Explanation";
                } else { // writing mode
                    systemPrompt = "You are a writing assistant. Refine the user's text, providing a well-structured and clear response. Only provide the refined text in Markdown, no extra conversational text.";
                    title = "Writing Refinement";
                }
                
                const payload = {
                    contents: [{
                        role: 'user',
                        parts: [{ text: `${systemPrompt}\n\n${prompt}` }]
                    }],
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.TEXT_MODEL}:generateContent?key=${window.API_KEY}`;
                
                try {
                    const response = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });
                    if (!response.ok) {
                        let errorData = await response.json();
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error.message}`);
                    }
                    const result = await response.json();
                    aiText = (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text) || aiText;
                } catch (error) {
                    console.error("Error generating canvas content:", error);
                    aiText = `Error: ${error.message}`;
                } finally {
                    setCanvasContent(aiText);
                    setCanvasTitle(title);
                    setCanvasId(immersiveId);
                    setIsAIGenerating(false);
                }
            };
            
            const sendAIMessage = async (content) => {
                const aiMessage = {
                    role: 'ai',
                    content: content,
                };

                if (db) {
                    try {
                        const collectionPath = `/artifacts/${window.appId}/users/${userId}/messages`;
                        await window.firebase.addDoc(window.firebase.collection(db, collectionPath), {
                            ...aiMessage,
                            timestamp: window.firebase.serverTimestamp(),
                        });
                    } catch (firestoreError) {
                        console.error("Error writing AI message to Firestore:", firestoreError);
                    }
                } else {
                    setMessages(prevMessages => [...prevMessages, aiMessage]);
                }
                
                setIsAIGenerating(false);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (mode === 'chat') {
                        handleSendMessage(input);
                    } else if (mode === 'writing') {
                        handleGenerateCanvas(input, 'writing');
                    } else if (mode === 'code') {
                        handleGenerateCanvas(input, 'code');
                    }
                }
            };

            const handleTextToSpeech = async (text) => {
                if (!audioContext || !text) return;
                
                // Exclude image markdown from being spoken
                const cleanText = text.replace(/\[Generated Image\]\(data:image\/png;base64,.*\)/, '');
                if (!cleanText.trim()) return;

                const payload = {
                    contents: [{
                        parts: [{ text: cleanText }]
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Puck" }
                            }
                        }
                    },
                    model: window.TTS_MODEL
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.TTS_MODEL}:generateContent?key=${window.API_KEY}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        console.error(`TTS API error: ${response.status} ${response.statusText}`);
                        return;
                    }

                    const result = await response.json();
                    const part = (result && result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0)
                        ? result.candidates[0].content.parts[0]
                        : null;
                    const audioData = (part && part.inlineData && part.inlineData.data);
                    const mimeType = (part && part.inlineData && part.inlineData.mimeType);

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                        const pcmData = window.base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = window.pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        const audio = new Audio(audioUrl);
                        audio.play();
                    } else {
                        console.error("TTS failed: No valid audio data in response.");
                    }
                } catch (error) {
                    console.error("Error during TTS generation:", error);
                }
            };
            
            const handleGenerateImage = () => {
                const prompt = `generate image of ${input}`;
                handleSendMessage(prompt);
            }

            const LoadingIndicator = () => (
                <div className="flex flex-col items-center justify-center h-full text-center text-gray-400">
                    <div className="dot-flashing mb-4"></div>
                    <p>Authenticating...</p>
                </div>
            );

            const ChatHistory = () => (
                <React.Fragment>
                    {messages.length === 0 && !isAIGenerating ? (
                        <div className="text-center text-gray-500 py-10">
                            <p>Start a conversation with Madison AI.</p>
                            <p>Ask me to refine your writing, explain code, or create new content.</p>
                            <p className="text-sm mt-2">Just type what you need and press send!</p>
                        </div>
                    ) : (
                        messages.map((msg, index) => (
                            <div
                                key={index}
                                className={`flex items-start space-x-3 ${msg.role === 'user' ? 'justify-end' : ''}`}
                            >
                                {msg.role === 'ai' && <BotIcon className="flex-shrink-0 text-indigo-400 mt-1" />}
                                <div className={`relative p-3 rounded-xl max-w-[80%] ${msg.role === 'user'
                                    ? 'bg-indigo-600 text-white rounded-br-none'
                                    : 'bg-gray-700 text-gray-100 rounded-bl-none'
                                    }`}>
                                    {msg.image && (
                                        <div className="mb-2">
                                            <img src={msg.image} alt="Uploaded" className="max-w-full h-auto rounded-lg" />
                                        </div>
                                    )}
                                    <div
                                        className="prose prose-sm prose-invert"
                                        dangerouslySetInnerHTML={{ __html: getParsedMarkdown(msg.content) }}
                                    ></div>
                                    {msg.role === 'ai' && !isAIGenerating && (
                                        <button
                                            onClick={() => handleTextToSpeech(msg.content)}
                                            className="absolute bottom-1 right-1 bg-gray-600 p-1 rounded-full text-gray-200 hover:text-white transition-colors"
                                        >
                                            <Volume2Icon size={16} />
                                        </button>
                                    )}
                                </div>
                                {msg.role === 'user' && <UserIcon className="flex-shrink-0 text-gray-400 mt-1" />}
                            </div>
                        ))
                    )}
                    {isAIGenerating && (
                        <div className="flex items-start space-x-3">
                            <BotIcon className="flex-shrink-0 text-indigo-400 mt-1" />
                            <div className="p-3 bg-gray-700 rounded-xl rounded-bl-none">
                                <div className="dot-flashing"></div>
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </React.Fragment>
            );

            const ImmersiveDocument = () => {
                if (!canvasContent) {
                    return (
                        <div className="text-center text-gray-500 py-10">
                            <p>Generate a document or code explanation.</p>
                            <p className="text-sm mt-2">The output will appear here, and you can edit it directly.</p>
                        </div>
                    );
                }

                // Split the content to find code blocks and markdown
                const isCode = canvasContent.startsWith('```');
                const contentBody = isCode ? canvasContent.substring(canvasContent.indexOf('\n') + 1, canvasContent.lastIndexOf('```')) : canvasContent;
                const contentType = isCode ? (canvasContent.match(/```(\w+)/) ? canvasContent.match(/```(\w+)/)[1] : 'text') : 'text';

                return (
                    <div className="w-full h-full p-4 bg-gray-800 rounded-lg overflow-y-auto">
                        <h2 className="text-xl font-bold mb-4">{canvasTitle}</h2>
                        {isCode ? (
                            <pre className="p-4 bg-gray-900 rounded-lg overflow-x-auto text-sm text-gray-300">
                                <code>{contentBody}</code>
                            </pre>
                        ) : (
                            <div
                                className="prose prose-sm prose-invert"
                                dangerouslySetInnerHTML={{ __html: getParsedMarkdown(canvasContent) }}
                            ></div>
                        )}
                    </div>
                );
            };

            const isCanvasMode = mode !== 'chat';
            const isWritingMode = mode === 'writing';
            const isCodeMode = mode === 'code';

            return (
                <div className="flex flex-col h-[calc(100vh-2rem)] bg-gray-900 rounded-lg shadow-2xl overflow-hidden max-w-4xl mx-auto">
                    {/* Header */}
                    <div className="flex items-center justify-between p-4 bg-gray-800 border-b border-gray-700">
                        <div className="flex items-center space-x-2">
                            <BotIcon className="text-indigo-400" size={28} />
                            <h1 className="text-xl font-bold text-white">Madison AI</h1>
                            <span className="text-xs text-gray-400 ml-2">
                                {isCanvasMode ? 'Canvas Mode' : 'Chat Mode'}
                            </span>
                        </div>
                        <div className="flex items-center space-x-2">
                            <div className="text-xs text-gray-400">
                                User ID: {userId || 'Authenticating...'}
                            </div>
                            <button
                                onClick={() => setMode(mode === 'chat' ? 'writing' : 'chat')}
                                className="p-2 bg-gray-700 text-white rounded-full shadow-lg hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={isAIGenerating || !isAuthReady || firestoreError}
                            >
                                {isCanvasMode ? <MessageSquareTextIcon size={16} /> : <SquareMenuIcon size={16} />}
                            </button>
                        </div>
                    </div>

                    {/* Main Content Window */}
                    <div className="flex-1 p-4 overflow-y-auto space-y-4" style={{ WebkitOverflowScrolling: 'touch' }}>
                        {!isAuthReady ? (
                            <LoadingIndicator />
                        ) : firestoreError ? (
                            <div className="text-center text-red-400 py-10">
                                <p>Error connecting to database:</p>
                                <p className="font-mono mt-2">{firestoreError}</p>
                                <p className="mt-4 text-sm text-red-300">This often means there's an issue with Firebase permissions.</p>
                            </div>
                        ) : apiKeyError ? (
                            <div className="text-center text-red-400 py-10">
                                <p>API Key Error:</p>
                                <p className="font-mono mt-2">{apiKeyError}</p>
                                <p className="mt-4 text-sm text-red-300">Please ensure the `__api_key` environment variable is set correctly.</p>
                            </div>
                        ) : isCanvasMode ? (
                            <ImmersiveDocument />
                        ) : (
                            <ChatHistory />
                        )}
                    </div>

                    {/* Input Area */}
                    <div className="p-4 bg-gray-800 border-t border-gray-700">
                        {selectedImage && (
                            <div className="relative mb-2">
                                <img src={selectedImage} alt="Preview" className="max-h-24 rounded-lg object-cover" />
                                <button
                                    onClick={handleRemoveImage}
                                    className="absolute top-1 right-1 bg-red-600 text-white rounded-full p-1 leading-none text-xs"
                                >
                                    &times;
                                </button>
                            </div>
                        )}
                        <div className="relative flex items-center bg-gray-700 rounded-full shadow-lg">
                            <textarea
                                ref={textareaRef}
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyDown={handleKeyDown}
                                className="w-full pl-6 pr-40 py-3 bg-transparent text-white placeholder-gray-400 rounded-full focus:outline-none resize-none overflow-hidden"
                                placeholder={isCanvasMode ? "Enter text or code to refine..." : "Send a message..."}
                                rows={1}
                                disabled={!isAuthReady || firestoreError || apiKeyError || isAIGenerating}
                            ></textarea>
                            <div className="absolute right-2 flex items-center space-x-2">
                                {!isCanvasMode ? (
                                    <React.Fragment>
                                        <label className="p-3 bg-gray-600 text-white rounded-full shadow-lg hover:bg-gray-700 transition-colors cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed">
                                            <input
                                                type="file"
                                                ref={fileInputRef}
                                                accept="image/*"
                                                onChange={handleImageChange}
                                                className="hidden"
                                                disabled={!isAuthReady || firestoreError || apiKeyError || isAIGenerating}
                                            />
                                            <ImageIcon size={16} />
                                        </label>
                                        <button
                                            className="p-3 bg-purple-600 text-white rounded-full shadow-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                            onClick={handleGenerateImage}
                                            disabled={isAIGenerating || !input.trim() || selectedImage || !isAuthReady || firestoreError || apiKeyError}
                                        >
                                            <WandIcon size={16} />
                                        </button>
                                        <button
                                            className="p-3 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                            onClick={() => handleSendMessage(input)}
                                            disabled={isAIGenerating || (!input.trim() && !selectedImage) || !isAuthReady || firestoreError || apiKeyError}
                                        >
                                            <SendIcon size={16} />
                                        </button>
                                    </React.Fragment>
                                ) : (
                                    <React.Fragment>
                                        <div className="flex items-center space-x-2 mr-2">
                                            <button
                                                className={`p-2 rounded-full shadow-lg transition-colors text-sm flex items-center gap-1
                                                    ${isWritingMode ? 'bg-indigo-600 text-white' : 'bg-gray-600 text-gray-200 hover:bg-gray-700'}`}
                                                onClick={() => setMode('writing')}
                                                disabled={isAIGenerating || !isAuthReady || firestoreError}
                                            >
                                                <WandIcon size={16} />
                                                <span className="font-semibold">Refine Writing</span>
                                            </button>
                                            <button
                                                className={`p-2 rounded-full shadow-lg transition-colors text-sm flex items-center gap-1
                                                    ${isCodeMode ? 'bg-indigo-600 text-white' : 'bg-gray-600 text-gray-200 hover:bg-gray-700'}`}
                                                onClick={() => setMode('code')}
                                                disabled={isAIGenerating || !isAuthReady || firestoreError}
                                            >
                                                <CodeIcon size={16} />
                                                <span className="font-semibold">Explain Code</span>
                                            </button>
                                        </div>
                                        <button
                                            className="p-3 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                            onClick={() => handleGenerateCanvas(input, isWritingMode ? 'writing' : 'code')}
                                            disabled={isAIGenerating || !input.trim() || !isAuthReady || firestoreError}
                                        >
                                            <SendIcon size={16} />
                                        </button>
                                    </React.Fragment>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Render the App component
        window.onload = function() {
            const root = document.getElementById('root');
            if (root) {
                ReactDOM.render(<App />, root);
            }
        };
    </script>
</body>
</html>

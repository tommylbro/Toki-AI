<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toki AI</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Third-party library for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
    <!-- Babel Standalone for JSX compilation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <!-- Firebase Libraries -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, getDoc, setDoc, onSnapshot, query, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

        // Firebase configuration from Canvas environment
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Expose Firebase objects to the global scope for the Babel script
        window.firebase = {
            db,
            auth,
            signInWithCustomToken,
            signInAnonymously,
            onAuthStateChanged,
            collection,
            doc,
            addDoc,
            getDoc,
            setDoc,
            onSnapshot,
            query,
            serverTimestamp
        };
        window.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.initialAuthToken = initialAuthToken;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .prose-sm {
            font-size: 0.875rem; /* 14px */
            line-height: 1.5;
        }
        /* Custom scrollbar for chat */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #2d3748;
            border-radius: 10px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased h-screen flex flex-col">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Custom icon components
        const SendIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const CodeIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="16 18 22 12 16 6"></polyline>
                <polyline points="8 6 2 12 8 18"></polyline>
            </svg>
        );

        const PenToolIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                <path d="M18 13l-1.5-7.5L2 2l7.5 1.5L18 13z"></path>
                <path d="M2 2l7.5 7.5"></path>
            </svg>
        );
        
        const MessageSquareIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
        );

        const Volume2Icon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );
        
        // Modal component for alerts
        const Modal = ({ show, title, message, onClose }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full border border-gray-700">
                        <h3 className="text-xl font-bold mb-2 text-indigo-400">{title}</h3>
                        <p className="text-gray-300 mb-4">{message}</p>
                        <button
                            onClick={onClose}
                            className="w-full p-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                        >
                            Close
                        </button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [input, setInput] = useState('');
            const [isWritingMode, setIsWritingMode] = useState(true);
            const [isChatMode, setIsChatMode] = useState(false);
            const [isAIGenerating, setIsAIGenerating] = useState(false);
            const [isLoadingTTS, setIsLoadingTTS] = useState(false);
            const [canvasArtifacts, setCanvasArtifacts] = useState([]);
            const [chatHistory, setChatHistory] = useState([]);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [userId, setUserId] = useState(null);
            const [firestoreError, setFirestoreError] = useState(null);
            const [showErrorModal, setShowErrorModal] = useState(false);
            const [modalMessage, setModalMessage] = useState('');
            const [markedLoaded, setMarkedLoaded] = useState(false);
            const chatContainerRef = useRef(null);
            const canvasContainerRef = useRef(null);

            // --- Helper Functions for TTS ---
            const base64ToArrayBuffer = (base64) => {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            };

            const pcmToWav = (pcmData, sampleRate) => {
                const pcm16 = new Int16Array(pcmData);
                const buffer = new ArrayBuffer(44 + pcm16.length * 2);
                const view = new DataView(buffer);
                const writeString = (view, offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                let offset = 0;
                writeString(view, offset, 'RIFF'); offset += 4;
                view.setUint32(offset, 36 + pcm16.length * 2, true); offset += 4;
                writeString(view, offset, 'WAVE'); offset += 4;
                writeString(view, offset, 'fmt '); offset += 4;
                view.setUint32(offset, 16, true); offset += 4;
                view.setUint16(offset, 1, true); offset += 2;
                view.setUint16(offset, 1, true); offset += 2; // Mono
                view.setUint32(offset, sampleRate, true); offset += 4;
                view.setUint32(offset, sampleRate * 2, true); offset += 4;
                view.setUint16(offset, 2, true); offset += 2;
                view.setUint16(offset, 16, true); offset += 2;
                writeString(view, offset, 'data'); offset += 4;
                view.setUint32(offset, pcm16.length * 2, true); offset += 4;
                for (let i = 0; i < pcm16.length; i++) {
                    view.setInt16(offset + i * 2, pcm16[i], true);
                }
                return new Blob([view], { type: 'audio/wav' });
            };


            // --- Firebase Initialization and Auth ---
            useEffect(() => {
                const initFirebase = async () => {
                    const { auth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } = window.firebase;
                    const initialAuthToken = window.initialAuthToken;

                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                        console.log("Firebase Auth successful");

                        const unsubscribe = onAuthStateChanged(auth, (user) => {
                            if (user) {
                                setUserId(user.uid);
                                console.log("User UID:", user.uid);
                            } else {
                                console.log("User signed out or not authenticated.");
                                setUserId(null);
                            }
                            setIsAuthReady(true);
                        });
                        return () => unsubscribe();
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        setFirestoreError(error.message);
                        setModalMessage(`Firebase Auth Error: ${error.message}. Please check your connection.`);
                        setShowErrorModal(true);
                    }
                };
                initFirebase();
            }, []);

            // --- Check for Marked.js Library ---
            useEffect(() => {
                const checkMarked = () => {
                    if (window.marked) {
                        setMarkedLoaded(true);
                    } else {
                        setTimeout(checkMarked, 100); // Polling for the library to be loaded
                    }
                };
                checkMarked();
            }, []);
            
            // --- Auto-scroll chat and canvas containers ---
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [chatHistory]);

            useEffect(() => {
                if (canvasContainerRef.current) {
                    canvasContainerRef.current.scrollTop = canvasContainerRef.current.scrollHeight;
                }
            }, [canvasArtifacts]);


            // --- Firestore Listener for Canvas Artifacts ---
            useEffect(() => {
                if (!isAuthReady || !userId) return;
                const { collection, onSnapshot, query } = window.firebase;
                const db = window.firebase.db;
                
                if (!db) {
                    console.error("Firestore DB not available.");
                    return;
                }

                const canvasPath = `artifacts/${window.appId}/users/${userId}/canvas`;
                const q = query(collection(db, canvasPath));

                console.log("Setting up Firestore listener on path:", canvasPath);
                
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const docs = [];
                    snapshot.forEach(doc => {
                        docs.push({ id: doc.id, ...doc.data() });
                    });
                    setCanvasArtifacts(docs.sort((a, b) => {
                        const timeA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                        const timeB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                        return timeA - timeB;
                    }));
                }, (error) => {
                    console.error("Firestore snapshot error:", error);
                    setFirestoreError(error.message);
                    setModalMessage(`Firestore Error: ${error.message}. Please check your security rules.`);
                    setShowErrorModal(true);
                });

                return () => unsubscribe();
            }, [isAuthReady, userId]);

            // --- Firestore Listener for Chat History ---
            useEffect(() => {
                if (!isAuthReady || !userId) return;
                const { collection, onSnapshot, query } = window.firebase;
                const db = window.firebase.db;

                if (!db) {
                    console.error("Firestore DB not available.");
                    return;
                }
                
                const conversationPath = `artifacts/${window.appId}/users/${userId}/conversations`;
                const q = query(collection(db, conversationPath));

                console.log("Setting up Firestore listener on path:", conversationPath);

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const docs = [];
                    snapshot.forEach(doc => {
                        docs.push({ id: doc.id, ...doc.data() });
                    });
                    setChatHistory(docs.sort((a, b) => {
                        const timeA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                        const timeB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                        return timeA - timeB;
                    }));
                }, (error) => {
                    console.error("Firestore snapshot error:", error);
                    setFirestoreError(error.message);
                    setModalMessage(`Firestore Error: ${error.message}. Please check your security rules.`);
                    setShowErrorModal(true);
                });

                return () => unsubscribe();
            }, [isAuthReady, userId]);


            // --- Gemini LLM API Call Function ---
            const generateContent = async (prompt, history = []) => {
                setIsAIGenerating(true);
                const chatHistoryPayload = history.map(item => ({ role: item.role, parts: [{ text: item.text }] }));
                chatHistoryPayload.push({ role: "user", parts: [{ text: prompt }] });
                
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                let attempt = 0;
                const maxAttempts = 5;
                const baseDelay = 1000;
                
                while (attempt < maxAttempts) {
                    try {
                        const payload = { contents: chatHistoryPayload };
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429) {
                                throw new Error('Too Many Requests');
                            }
                            throw new Error(`API error: ${response.statusText}`);
                        }

                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const text = result.candidates[0].content.parts[0].text;
                            return text;
                        } else {
                            throw new Error("Invalid response from API");
                        }
                    } catch (error) {
                        console.error(`Attempt ${attempt + 1} failed:`, error);
                        attempt++;
                        if (attempt < maxAttempts) {
                            const delay = baseDelay * Math.pow(2, attempt);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw error;
                        }
                    }
                }
                return null;
            };

            // --- Gemini TTS API Call Function ---
            const handleTextToSpeech = async (text) => {
                setIsLoadingTTS(true);
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say in a clear voice: ${text}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Kore" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const candidates = result.candidates;
                    const audioPart = candidates && candidates[0] && candidates[0].content && candidates[0].content.parts && candidates[0].content.parts[0];
                    
                    if (!audioPart || !audioPart.inlineData) {
                        throw new Error("Invalid TTS response from API");
                    }
                    
                    const audioData = audioPart.inlineData.data;
                    const mimeType = audioPart.inlineData.mimeType;

                    const sampleRateMatc            collection,
            doc,
            addDoc,
            getDoc,
            setDoc,
            onSnapshot,
            query,
            serverTimestamp
        };
        window.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.initialAuthToken = initialAuthToken;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .prose-sm {
            font-size: 0.875rem; /* 14px */
            line-height: 1.5;
        }
        /* Custom scrollbar for chat */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #2d3748;
            border-radius: 10px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased h-screen flex flex-col">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Custom icon components
        const SendIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const CodeIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="16 18 22 12 16 6"></polyline>
                <polyline points="8 6 2 12 8 18"></polyline>
            </svg>
        );

        const PenToolIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                <path d="M18 13l-1.5-7.5L2 2l7.5 1.5L18 13z"></path>
                <path d="M2 2l7.5 7.5"></path>
            </svg>
        );
        
        const MessageSquareIcon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
        );

        const Volume2Icon = ({ size = 24, className = 'text-white' }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );
        
        // Modal component for alerts
        const Modal = ({ show, title, message, onClose }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full border border-gray-700">
                        <h3 className="text-xl font-bold mb-2 text-indigo-400">{title}</h3>
                        <p className="text-gray-300 mb-4">{message}</p>
                        <button
                            onClick={onClose}
                            className="w-full p-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                        >
                            Close
                        </button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [input, setInput] = useState('');
            const [isWritingMode, setIsWritingMode] = useState(true);
            const [isChatMode, setIsChatMode] = useState(false);
            const [isAIGenerating, setIsAIGenerating] = useState(false);
            const [isLoadingTTS, setIsLoadingTTS] = useState(false);
            const [canvasArtifacts, setCanvasArtifacts] = useState([]);
            const [chatHistory, setChatHistory] = useState([]);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [userId, setUserId] = useState(null);
            const [firestoreError, setFirestoreError] = useState(null);
            const [showErrorModal, setShowErrorModal] = useState(false);
            const [modalMessage, setModalMessage] = useState('');
            const [markedLoaded, setMarkedLoaded] = useState(false);
            const chatContainerRef = useRef(null);
            const canvasContainerRef = useRef(null);

            // --- Helper Functions for TTS ---
            const base64ToArrayBuffer = (base64) => {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            };

            const pcmToWav = (pcmData, sampleRate) => {
                const pcm16 = new Int16Array(pcmData);
                const buffer = new ArrayBuffer(44 + pcm16.length * 2);
                const view = new DataView(buffer);
                const writeString = (view, offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                let offset = 0;
                writeString(view, offset, 'RIFF'); offset += 4;
                view.setUint32(offset, 36 + pcm16.length * 2, true); offset += 4;
                writeString(view, offset, 'WAVE'); offset += 4;
                writeString(view, offset, 'fmt '); offset += 4;
                view.setUint32(offset, 16, true); offset += 4;
                view.setUint16(offset, 1, true); offset += 2;
                view.setUint16(offset, 1, true); offset += 2; // Mono
                view.setUint32(offset, sampleRate, true); offset += 4;
                view.setUint32(offset, sampleRate * 2, true); offset += 4;
                view.setUint16(offset, 2, true); offset += 2;
                view.setUint16(offset, 16, true); offset += 2;
                writeString(view, offset, 'data'); offset += 4;
                view.setUint32(offset, pcm16.length * 2, true); offset += 4;
                for (let i = 0; i < pcm16.length; i++) {
                    view.setInt16(offset + i * 2, pcm16[i], true);
                }
                return new Blob([view], { type: 'audio/wav' });
            };


            // --- Firebase Initialization and Auth ---
            useEffect(() => {
                const initFirebase = async () => {
                    const { auth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } = window.firebase;
                    const initialAuthToken = window.initialAuthToken;

                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                        console.log("Firebase Auth successful");

                        const unsubscribe = onAuthStateChanged(auth, (user) => {
                            if (user) {
                                setUserId(user.uid);
                                console.log("User UID:", user.uid);
                            } else {
                                console.log("User signed out or not authenticated.");
                                setUserId(null);
                            }
                            setIsAuthReady(true);
                        });
                        return () => unsubscribe();
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        setFirestoreError(error.message);
                        setModalMessage(`Firebase Auth Error: ${error.message}. Please check your connection.`);
                        setShowErrorModal(true);
                    }
                };
                initFirebase();
            }, []);

            // --- Check for Marked.js Library ---
            useEffect(() => {
                const checkMarked = () => {
                    if (window.marked) {
                        setMarkedLoaded(true);
                    } else {
                        setTimeout(checkMarked, 100); // Polling for the library to be loaded
                    }
                };
                checkMarked();
            }, []);
            
            // --- Auto-scroll chat and canvas containers ---
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [chatHistory]);

            useEffect(() => {
                if (canvasContainerRef.current) {
                    canvasContainerRef.current.scrollTop = canvasContainerRef.current.scrollHeight;
                }
            }, [canvasArtifacts]);


            // --- Firestore Listener for Canvas Artifacts ---
            useEffect(() => {
                if (!isAuthReady || !userId) return;
                const { collection, onSnapshot, query } = window.firebase;
                const db = window.firebase.db;
                
                if (!db) {
                    console.error("Firestore DB not available.");
                    return;
                }

                const canvasPath = `artifacts/${window.appId}/users/${userId}/canvas`;
                const q = query(collection(db, canvasPath));

                console.log("Setting up Firestore listener on path:", canvasPath);
                
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const docs = [];
                    snapshot.forEach(doc => {
                        docs.push({ id: doc.id, ...doc.data() });
                    });
                    setCanvasArtifacts(docs.sort((a, b) => {
                        const timeA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                        const timeB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                        return timeA - timeB;
                    }));
                }, (error) => {
                    console.error("Firestore snapshot error:", error);
                    setFirestoreError(error.message);
                    setModalMessage(`Firestore Error: ${error.message}. Please check your security rules.`);
                    setShowErrorModal(true);
                });

                return () => unsubscribe();
            }, [isAuthReady, userId]);

            // --- Firestore Listener for Chat History ---
            useEffect(() => {
                if (!isAuthReady || !userId) return;
                const { collection, onSnapshot, query } = window.firebase;
                const db = window.firebase.db;

                if (!db) {
                    console.error("Firestore DB not available.");
                    return;
                }
                
                const conversationPath = `artifacts/${window.appId}/users/${userId}/conversations`;
                const q = query(collection(db, conversationPath));

                console.log("Setting up Firestore listener on path:", conversationPath);

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const docs = [];
                    snapshot.forEach(doc => {
                        docs.push({ id: doc.id, ...doc.data() });
                    });
                    setChatHistory(docs.sort((a, b) => {
                        const timeA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                        const timeB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                        return timeA - timeB;
                    }));
                }, (error) => {
                    console.error("Firestore snapshot error:", error);
                    setFirestoreError(error.message);
                    setModalMessage(`Firestore Error: ${error.message}. Please check your security rules.`);
                    setShowErrorModal(true);
                });

                return () => unsubscribe();
            }, [isAuthReady, userId]);


            // --- Gemini LLM API Call Function ---
            const generateContent = async (prompt, history = []) => {
                setIsAIGenerating(true);
                const chatHistoryPayload = history.map(item => ({ role: item.role, parts: [{ text: item.text }] }));
                chatHistoryPayload.push({ role: "user", parts: [{ text: prompt }] });
                
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                let attempt = 0;
                const maxAttempts = 5;
                const baseDelay = 1000;
                
                while (attempt < maxAttempts) {
                    try {
                        const payload = { contents: chatHistoryPayload };
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429) {
                                throw new Error('Too Many Requests');
                            }
                            throw new Error(`API error: ${response.statusText}`);
                        }

                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const text = result.candidates[0].content.parts[0].text;
                            return text;
                        } else {
                            throw new Error("Invalid response from API");
                        }
                    } catch (error) {
                        console.error(`Attempt ${attempt + 1} failed:`, error);
                        attempt++;
                        if (attempt < maxAttempts) {
                            const delay = baseDelay * Math.pow(2, attempt);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw error;
                        }
                    }
                }
                return null;
            };

            // --- Gemini TTS API Call Function ---
            const handleTextToSpeech = async (text) => {
                setIsLoadingTTS(true);
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say in a clear voice: ${text}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Kore" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const candidates = result.candidates;
                    const audioPart = candidates && candidates[0] && candidates[0].content && candidates[0].content.parts && candidates[0].content.parts[0];
                    
                    if (!audioPart || !audioPart.inlineData) {
                        throw new Error("Invalid TTS response from API");
                    }
                    
                    const audioData = audioPart.inlineData.data;
                    const mimeType = audioPart.inlineData.mimeType;

                    const sampleRateMatc            scrollbar-width: thin;
            scrollbar-color: #4a5568 #1a202c;
        }
        
        .dot-flashing {
            position: relative;
            width: 10px;
            height: 10px;
            border-radius: 5px;
            background-color: #9e9e9e;
            color: #9e9e9e;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: 0.5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
        }
        .dot-flashing::before {
            left: -15px;
            width: 10px;
            height: 10px;
            border-radius: 5px;
            background-color: #9e9e9e;
            color: #9e9e9e;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 15px;
            width: 10px;
            height: 10px;
            border-radius: 5px;
            background-color: #9e9e9e;
            color: #9e9e9e;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }
        @keyframes dotFlashing {
            0% {
                background-color: #9e9e9e;
            }
            50%, 100% {
                background-color: #e2e8f0;
            }
        }
        .prose-sm {
            font-size: 0.875rem;
            line-height: 1.5;
        }
        .prose-sm h1 { font-size: 1.5em; }
        .prose-sm h2 { font-size: 1.25em; }
        .prose-sm h3 { font-size: 1.1em; }
        .prose-sm ul { list-style-type: disc; padding-left: 1.5em; }
        .prose-sm ol { list-style-type: decimal; padding-left: 1.5em; }
        .prose-sm pre { background-color: #2d3748; padding: 1em; border-radius: 0.5em; overflow-x: auto; }
        .prose-sm code { font-size: 0.8em; background-color: #2d3748; padding: 0.2em 0.4em; border-radius: 0.25em; }
        .prose-sm pre code { padding: 0; background-color: transparent; }
        .prose-sm p, .prose-sm li { margin-bottom: 0.5em; }
        .prose-sm strong { font-weight: 600; }

        /* The canvas container for dynamic content */
        #canvas-container {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    <div id="app-container" class="h-screen flex flex-col justify-center items-center p-4">
        <div id="chat-container" class="w-full max-w-4xl h-full flex flex-col bg-gray-800 rounded-lg shadow-xl overflow-hidden">
            <!-- Chat messages display area -->
            <div id="chat-messages" class="flex-1 p-6 space-y-4 overflow-y-auto custom-scrollbar">
                <!-- Welcome message -->
                <div class="flex flex-col items-center justify-center text-gray-400 text-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mb-4">
                        <path d="M12 8V4H8" /><rect width="16" height="12" x="4" y="8" rx="2" /><path d="M2 14h2" /><path d="M20 14h2" /><path d="M15 13l2 2" /><path d="M7 13l-2 2" /><path d="M12 18h.01" /><path d="M7 21h10" /><path d="M12 4v4" />
                    </svg>
                    <h2 class="text-xl font-semibold">Start a conversation</h2>
                    <p>Type a message below to begin.</p>
                    <div class="mt-8">
                        <h3 class="text-lg font-semibold">Special Commands:</h3>
                        <ul class="list-disc list-inside text-left">
                            <li><strong>Generate Image:</strong> <code>generate image of [your prompt]</code></li>
                            <li><strong>Generate Document:</strong> <code>create a writing document of [your topic]</code></li>
                            <li><strong>Generate Code:</strong> <code>create a code document of [your code request]</code></li>
                        </ul>
                    </div>
                </div>
                <!-- Loading indicator -->
                <div id="loading-indicator" class="hidden flex items-center space-x-2 p-4 rounded-xl my-2 max-w-3xl bg-gray-700 text-gray-100">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 8V4H8" /><rect width="16" height="12" x="4" y="8" rx="2" /><path d="M2 14h2" /><path d="M20 14h2" /><path d="M15 13l2 2" /><path d="M7 13l-2 2" /><path d="M12 18h.01" /><path d="M7 21h10" /><path d="M12 4v4" />
                    </svg>
                    <div class="flex space-x-1">
                        <div class="dot-flashing"></div>
                        <div class="dot-flashing" style="animation-delay: 0.2s;"></div>
                        <div class="dot-flashing" style="animation-delay: 0.4s;"></div>
                    </div>
                </div>
            </div>

            <!-- Chat input area -->
            <div class="p-4 border-t border-gray-700 bg-gray-800">
                <div id="image-preview" class="hidden relative mb-2 w-24 h-24 rounded-lg overflow-hidden border-2 border-gray-600">
                    <img id="preview-image" src="" alt="Preview" class="w-full h-full object-cover">
                    <button id="remove-image-btn" class="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <input type="file" id="image-file-input" class="hidden" accept="image/*">
                    <button id="upload-image-btn" class="p-3 bg-gray-700 text-gray-300 rounded-full hover:bg-gray-600 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" />
                        </svg>
                    </button>
                    <textarea id="chat-input" class="flex-1 p-3 bg-gray-700 rounded-xl resize-none max-h-32 overflow-y-auto custom-scrollbar focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type a message..." rows="1"></textarea>
                    <button id="send-btn" class="p-3 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 2 11 13" /><path d="m22 2-7 20-4-9-9-4 20-7Z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Canvas container for documents -->
        <div id="canvas-container" class="w-full max-w-4xl h-full flex flex-col bg-gray-800 rounded-lg shadow-xl overflow-hidden">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 bg-gray-900 flex justify-between items-center">
                <h2 id="canvas-title" class="text-xl font-semibold text-white"></h2>
                <button id="close-canvas-btn" class="p-2 bg-gray-700 text-gray-300 rounded-full hover:bg-gray-600 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 8V4H8" /><rect width="16" height="12" x="4" y="8" rx="2" /><path d="M2 14h2" /><path d="M20 14h2" /><path d="M15 13l2 2" /><path d="M7 13l-2 2" /><path d="M12 18h.01" /><path d="M7 21h10" /><path d="M12 4v4" />
                    </svg>
                </button>
            </div>
            <div id="canvas-content" class="flex-1 p-6 overflow-y-auto custom-scrollbar prose-sm prose-invert">
                <!-- Content will be injected here -->
            </div>
        </div>

        <!-- Mode switcher for chat/canvas -->
        <div class="flex-shrink-0 mt-4 p-4 bg-gray-900 rounded-lg shadow-xl flex items-center justify-between space-x-4">
            <button id="chat-mode-btn" class="p-3 bg-blue-600 text-white rounded-full transition-colors" title="Switch to Chat">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 8V4H8" /><rect width="16" height="12" x="4" y="8" rx="2" /><path d="M2 14h2" /><path d="M20 14h2" /><path d="M15 13l2 2" /><path d="M7 13l-2 2" /><path d="M12 18h.01" /><path d="M7 21h10" /><path d="M12 4v4" />
                </svg>
            </button>
            <div class="flex items-center space-x-2">
                <button id="writing-mode-btn" class="p-3 bg-gray-700 text-gray-300 rounded-full hover:bg-gray-600 transition-colors" title="Generate Document">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect width="18" height="18" x="3" y="3" rx="2" /><path d="M7 8h10" /><path d="M7 12h10" /><path d="M7 16h10" />
                    </svg>
                </button>
                <button id="code-mode-btn" class="p-3 bg-gray-700 text-gray-300 rounded-full hover:bg-gray-600 transition-colors" title="Generate Code">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m18 16 4-4-4-4" /><path d="m6 8-4 4 4 4" /><path d="m14.5 4-5 16" />
                    </svg>
                </button>
            </div>
            <div id="user-id-display" class="text-gray-500 text-sm italic"></div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase services
        let app;
        let db;
        let auth;
        let userId;

        // Configuration variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const chatMessagesDiv = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const userIdDisplay = document.getElementById('user-id-display');
        const uploadImageBtn = document.getElementById('upload-image-btn');
        const imageFileInput = document.getElementById('image-file-input');
        const imagePreviewDiv = document.getElementById('image-preview');
        const previewImage = document.getElementById('preview-image');
        const removeImageBtn = document.getElementById('remove-image-btn');

        const chatContainer = document.getElementById('chat-container');
        const canvasContainer = document.getElementById('canvas-container');
        const chatModeBtn = document.getElementById('chat-mode-btn');
        const closeCanvasBtn = document.getElementById('close-canvas-btn');
        const writingModeBtn = document.getElementById('writing-mode-btn');
        const codeModeBtn = document.getElementById('code-mode-btn');
        const canvasTitle = document.getElementById('canvas-title');
        const canvasContent = document.getElementById('canvas-content');
        
        let selectedImageData = null;
        let isAIGenerating = false;

        // Helper for exponential backoff in API calls
        const fetchWithRetry = async (url, options, retries = 5) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 && i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    return response;
                } catch (error) {
                    if (i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        await new new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    throw error;
                }
            }
            throw new Error("Failed to fetch after multiple retries.");
        };

        // Helper for TTS audio conversion
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm, sampleRate) => {
            const pcmData = new Int16Array(pcm);
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);

            let offset = 0;
            const writeString = (str) => {
                for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
                offset += str.length;
            };
            const writeUint32 = (data) => { view.setUint32(offset, data, true); offset += 4; };
            const writeUint16 = (data) => { view.setUint16(offset, data, true); offset += 2; };

            writeString('RIFF');
            writeUint32(36 + pcmData.length * 2);
            writeString('WAVE');
            writeString('fmt ');
            writeUint32(16);
            writeUint16(1);
            writeUint16(1);
            writeUint32(sampleRate);
            writeUint32(sampleRate * 2);
            writeUint16(2);
            writeUint16(16);
            writeString('data');
            writeUint32(pcmData.length * 2);

            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += 2;
            }
            return new Blob([view], { type: 'audio/wav' });
        };

        // UI rendering functions
        function createMessageElement(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex items-start space-x-2 p-4 rounded-xl shadow-lg my-2 max-w-3xl ${message.role === 'user' ? 'bg-blue-600 text-white self-end ml-auto' : 'bg-gray-700 text-gray-100 self-start mr-auto'}`;

            const iconSvg = message.role === 'user' ? 
                `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></svg>` :
                `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8" /><rect width="16" height="12" x="4" y="8" rx="2" /><path d="M2 14h2" /><path d="M20 14h2" /><path d="M15 13l2 2" /><path d="M7 13l-2 2" /><path d="M12 18h.01" /><path d="M7 21h10" /><path d="M12 4v4" /></svg>`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = "flex-grow";

            if (message.image) {
                const img = document.createElement('img');
                img.src = message.image;
                img.alt = message.role === 'user' ? "User upload" : "Generated Image";
                img.className = "mt-2 rounded-lg shadow-md max-w-full h-auto";
                contentDiv.appendChild(img);
            } else if (window.marked) {
                const parsedMarkdown = window.marked.parse(message.content);
                const immersiveRegex = /<immersive[^>]*>([\s\S]*?)<\/immersive>/g;
                contentDiv.innerHTML = parsedMarkdown.replace(immersiveRegex, '$1');
            } else {
                contentDiv.textContent = message.content;
            }

            messageDiv.innerHTML = `<div class="flex-shrink-0 mt-1">${iconSvg}</div>`;
            messageDiv.appendChild(contentDiv);
            
            if (message.role === 'ai' && !message.image) {
                const speakerButton = document.createElement('button');
                speakerButton.className = "flex-shrink-0 text-gray-400 hover:text-white ml-2";
                speakerButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>`;
                speakerButton.title = "Speak";
                speakerButton.onclick = () => handleSpeak(message.content);
                messageDiv.appendChild(speakerButton);
            }
            
            return messageDiv;
        }

        function scrollToBottom() {
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }
        
        function showLoadingIndicator(show, message = 'AI is thinking...') {
            loadingIndicator.style.display = show ? 'flex' : 'none';
            const loadingText = loadingIndicator.querySelector('p');
            if (loadingText) {
                loadingText.textContent = message;
            } else {
                const p = document.createElement('p');
                p.textContent = message;
                loadingIndicator.appendChild(p);
            }
        }

        function showCanvas(content, title) {
            chatContainer.style.display = 'none';
            canvasContainer.style.display = 'flex';
            canvasTitle.textContent = title;
            if (window.marked) {
                canvasContent.innerHTML = window.marked.parse(content);
            } else {
                canvasContent.textContent = content;
            }
            chatModeBtn.classList.remove('bg-blue-600', 'text-white');
            chatModeBtn.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
        }
        
        function showChat() {
            chatContainer.style.display = 'flex';
            canvasContainer.style.display = 'none';
            chatModeBtn.classList.add('bg-blue-600', 'text-white');
            chatModeBtn.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
        }
        
        async function generateText(prompt, image) {
            let aiText = "I'm sorry, I couldn't get a response from the AI at the moment. Please try again later.";
            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: prompt },
                        ...(image ? [{ inlineData: { mimeType: "image/png", data: image.split(',')[1] } }] : [])
                    ]
                }]
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=`;
            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                aiText = (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) || aiText;
            } catch (error) {
                console.error("Error with text generation API:", error);
                aiText = `Error generating text: ${error.message}`;
            }
            return aiText;
        }

        async function generateImage(prompt) {
            let aiImage = null;
            let aiText = `I'm sorry, I couldn't generate an image at the moment. Please try again later.`;
            const payload = {
                contents: [{
                    parts: [{ text: prompt }]
                }],
                generationConfig: {
                    responseModalities: ['TEXT', 'IMAGE']
                },
            };
            const apiKey = "AIzaSyBvD0xGYQpFTND8Eqnh-KWhDA9YKQHZ6jg";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=${apiKey}`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Image generation API error:", errorData);
                    aiText = `Error generating image: ${errorData.error.message || 'An unknown error occurred.'}`;
                    return { text: aiText, image: aiImage };
                }

                const result = await response.json();
                const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                if (base64Data) {
                    aiImage = `data:image/png;base64,${base64Data}`;
                    aiText = `Here is the image you requested.`;
                } else {
                    console.error("Invalid image generation response:", result);
                    aiText = `Error generating image: Invalid response format. This may be due to content policy violations or an overly complex prompt. Please try a simpler prompt.`;
                }
            } catch (error) {
                console.error("Error with image generation API:", error);
                aiText = `Error generating image: ${error.message}`;
            }

            return { text: aiText, image: aiImage };
        }


        // API interaction functions
        async function handleSendMessage(prompt) {
            if (!prompt.trim() && !selectedImageData) return;

            isAIGenerating = true;
            showLoadingIndicator(true, 'AI is thinking...');
            
            // Create the message object to be displayed in the chat
            const newUserMessage = {
                role: 'user',
                content: prompt,
                image: selectedImageData,
                timestamp: Date.now(),
            };

            chatMessagesDiv.appendChild(createMessageElement(newUserMessage));
            scrollToBottom();

            chatInput.value = '';
            chatInput.style.height = 'auto';
            const tempSelectedImageData = selectedImageData;
            selectedImageData = null;
            imagePreviewDiv.style.display = 'none';
            previewImage.src = '';

            // Save a copy of the user message to Firestore without the image data
            if (db && userId) {
                const firestoreUserMessage = { ...newUserMessage, timestamp: serverTimestamp() };
                delete firestoreUserMessage.image; // Do not save large image data
                await addDoc(collection(db, `/artifacts/${appId}/users/${userId}/messages`), firestoreUserMessage);
            }

            let newAIMessage = { role: 'ai', content: '', timestamp: Date.now(), image: null };
            const imageGenRegex = /^(generate|create) an image of/i;

            if (imageGenRegex.test(prompt)) {
                showLoadingIndicator(true, 'Generating image...');
                const imagePrompt = prompt.replace(imageGenRegex, '').trim();
                const result = await generateImage(imagePrompt);
                newAIMessage.content = result.text;
                newAIMessage.image = result.image;
            } else {
                newAIMessage.content = await generateText(prompt, tempSelectedImageData);
            }

            chatMessagesDiv.appendChild(createMessageElement(newAIMessage));
            scrollToBottom();
            showLoadingIndicator(false);
            isAIGenerating = false;

            // Save a copy of the AI message to Firestore without the image data
            if (db && userId) {
                const firestoreAIMessage = { ...newAIMessage, timestamp: serverTimestamp() };
                delete firestoreAIMessage.image; // Do not save large image data
                await addDoc(collection(db, `/artifacts/${appId}/users/${userId}/messages`), firestoreAIMessage);
            }
        }
        
        async function handleGenerateCanvas(prompt, type) {
            if (!prompt.trim()) return;

            isAIGenerating = true;
            showLoadingIndicator(true);

            let canvasContentText = `Error generating document. Please try a different prompt or try again later.`;

            const payload = {
                contents: [{ parts: [{ text: `Generate content for a canvas. The user request is: "${prompt}". The content type is ${type}. Respond with the full content of the canvas document. The content should be a complete, self-contained block of Markdown or code. Do not include any conversational text outside the canvas. Do not include <immersive> tags. Just provide the raw content.` }] }],
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                canvasContentText = (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) || canvasContentText;
            } catch (error) {
                console.error("Error generating canvas content:", error);
                canvasContentText = `Error generating canvas content: ${error.message}`;
            }

            const title = type === 'code' ? 'Generated Code' : 'Generated Document';
            showCanvas(canvasContentText, title);
            showLoadingIndicator(false);
            isAIGenerating = false;
        }

        async function handleExplainCode(code) {
             if (!code.trim()) {
                 alert("Please provide some code to explain.");
                 return;
             }

             isAIGenerating = true;
             showLoadingIndicator(true, 'Explaining code...');

             let explanationText = "I'm sorry, I couldn't explain the code at the moment. Please try again later.";
             
             const prompt = `Explain the following code in a clear and concise manner. Use Markdown for formatting.
             
             \`\`\`
             ${code}
             \`\`\``;

             try {
                const response = await generateText(prompt);
                explanationText = response;
             } catch (error) {
                console.error("Error explaining code:", error);
                explanationText = `Error explaining code: ${error.message}`;
             }

             // Display the explanation in the canvas
             showCanvas(explanationText, 'Code Explanation');
             showLoadingIndicator(false);
             isAIGenerating = false;
        }
        
        async function handleSpeak(text) {
            if (!text) return;
            const payload = {
                contents: [{ parts: [{ text: `Say in a natural tone: ${text}` }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts",
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    console.error("Invalid TTS response format:", result);
                }
            } catch (error) {
                console.error("Error with TTS API:", error);
            }
        }


        // Event listeners and initialization
        window.onload = function() {
            if (firebaseConfig) {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    
                    onAuthStateChanged(auth, async (user) => {
                        if (!user) {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                } else {
                                    await signInAnonymously(auth);
                                }
                                user = auth.currentUser;
                            } catch (error) {
                                console.error("Firebase Auth Error:", error);
                            }
                        }
                        if (user) {
                            userId = user.uid;
                            userIdDisplay.textContent = `User ID: ${userId.substring(0, 8)}...`;
                            const q = query(collection(db, `/artifacts/${appId}/users/${userId}/messages`), orderBy('timestamp', 'asc'));
                            onSnapshot(q, (querySnapshot) => {
                                let messages = [];
                                querySnapshot.forEach((doc) => {
                                    messages.push(doc.data());
                                });
                                // Clear current messages and re-render
                                chatMessagesDiv.innerHTML = '';
                                if (messages.length === 0) {
                                    // Re-add welcome message if no messages
                                    const welcomeMessage = document.querySelector('#chat-messages > div:first-child');
                                    if (welcomeMessage) {
                                        chatMessagesDiv.appendChild(welcomeMessage);
                                    }
                                } else {
                                    messages.forEach(msg => chatMessagesDiv.appendChild(createMessageElement(msg)));
                                }
                                scrollToBottom();
                            });
                        } else {
                            console.error("User not authenticated.");
                        }
                    });
                } catch (error) {
                    console.error("Firebase Initialization Error:", error);
                }
            } else {
                console.warn("Firebase config not found. Running in offline mode.");
            }

            sendBtn.addEventListener('click', () => {
                if (!isAIGenerating) {
                    handleSendMessage(chatInput.value);
                }
            });

            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !isAIGenerating) {
                    e.preventDefault();
                    handleSendMessage(chatInput.value);
                }
            });

            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = `${chatInput.scrollHeight}px`;
            });

            uploadImageBtn.addEventListener('click', () => {
                imageFileInput.click();
            });

            imageFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        selectedImageData = reader.result;
                        previewImage.src = selectedImageData;
                        imagePreviewDiv.style.display = 'block';
                    };
                    reader.readAsDataURL(file);
                }
            });

            removeImageBtn.addEventListener('click', () => {
                selectedImageData = null;
                previewImage.src = '';
                imagePreviewDiv.style.display = 'none';
                imageFileInput.value = '';
            });

            chatModeBtn.addEventListener('click', showChat);
            closeCanvasBtn.addEventListener('click', showChat);
            writingModeBtn.addEventListener('click', () => {
                handleGenerateCanvas(chatInput.value, 'writing');
            });
            codeModeBtn.addEventListener('click', () => {
                handleGenerateCanvas(chatInput.value, 'code');
            });
        };
    </script>
</body>
</html>
